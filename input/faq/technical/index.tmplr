Title: Technical FAQ
----


<blockquote>
 <ul class="invisible">
  <li><a href="#faq_bodies">How can I modify message bodies?</a></li>
  <li><a href="#faq_rfc2047">Parsing of headers is broken (to/from/subject)?</a></li>
  <li><a href="#faq_tab">How does TAB-completion, and character input work?</a></li>
  <li><a href="#faq_gpg">How can I handle GPG?</a></li>
  <li><a href="#faq_iterate">How can I iterate over messages?</a></li>
  <li><a href="#faq_sort">Why is the sort-order of my messages wrong?</a></li>
  <li><a href="#faq_state">Many functions need to save/restore state, how can that be done?</a></li>
  <li><a href="#faq_msmtp">How can I use msmtp?</a></li>
 </ul>
 <p>&nbsp;</p>
</blockquote>


<p>&nbsp;</p>

<h4 id="faq_bodies">How can I modify message bodies?</h4>
<blockquote>
<p>There are times when it is necessary to modify a message prior to display.  Lumail provides two ways in which you can modify the message:</p>
<ol>
<li><a href="/lua/on_get_body.html">on_get_body()</a></li>
<li><a href="/lua/mail_filter.html">mail_filter()</a></li>
</ol>
<p>The <span class="tt">on_get_body()</span> function is called initially when a message is to be displayed.  If that returns a non-empty string then the output will be used as the body to display.  This allows you to juggle MIME-parts, convert HTML to text, etc.</p>
<p>If you don't use the <span class="tt">on_get_body()</span> function then the contents of the message will be read from the disk, and piped through the system command defined with <span class="tt">mail_filter()</span>.</p>
<p>Finally just prior to the display the message body will be passed through the shell-command defined in <span class="tt">display_filter()</span>.</p>
<p>This means you have two ways of filtering a command, both via the shell:</p>
<ul>
<li><span class="tt">display_filter</span> - Will filter just the text which is displayed upon the screen.</li>
<li><span class="tt">mail_filter</span> - Will filter just the whole message (headers, attachments, and all).</li>
</ul>
</blockquote>


<p>&nbsp;</p>


<h4 id="faq_rfc2047">Parsing of headers is broken (to/from/subject)?</h4>
<blockquote>
<p>We use <a href="http://spruce.sourceforge.net/gmime/">GMime</a> for parsing headers, message-bodies, and attachments.</p>
<p>By default GMime is pretty strict, but it has a looser mode which can be enabled via custom flags.  If you're seeing some oddities with decoding of headers in particular please set the environmental variable <span class="tt">RFC2047</span> to a non-empty value.</p>
<p>Upon a typical host you could do that via:</p>
<pre>
RFC2047=1 lumail [...args...]
</pre>
</blockquote>


<p>&nbsp;</p>

<h4 id="faq_tab">How does TAB-completion, and character input work?</h4>
<blockquote>
<p>Every time you're prompted for input, in the status-area, the code which handles it is that used by the <a href="/lua/prompt.html">prompt()</a> primitive.   This function reads individual characters and allows you to enter a complete "line".</p>
<p>This function has been written to have the standard keybindings you might find via readline, etc.  For example:</p>
<ul>
<li><span class="tt">Ctrl-a</span>: Go to beginning of line.</li>
<li><span class="tt">Ctrl-b</span>: Go backwards one character.</li>
<li><span class="tt">Ctrl-e</span>: Go to the end of line.</li>
<li><span class="tt">Ctrl-f</span>: Go forwards one character.</li>
<li><span class="tt">Ctrl-k</span>: Kill the reminder of the line.</li>
</ul>
<p>The reading of individual characters, along with all keyboard input, uses two sources of keys:</p>
<ul>
<li>The private input queue which has been seeded with <a href="/lua/stuff.html">stuff()</a>.</li>
<li>The ncurses input queue.</li>
</ul>
<p>By using the private input buffer, and only reading the keyboard with ncurses when that is empty, we allow the user-interface to be driven via automation, which is very useful.</p>
<p>The only part of the input-phase which is non-deterministic is the TAB-completion support.  When you're entering a line and you press TAB the line you've entered is broken into two parts:</p>
<ul>
<li>The start of the line, which is left unchanged.</li>
<li>The "word" you're currently entering, which is passed to the completion code.</li>
</ul>
<p><p>(i.e. Rather than using TAB-completion to complete a line it is always used to complete the "word", or token, you're currently entering.)</p>
<p>The word you're completing is determined by breaking up the line into pieces, based upon a small list of terminating-characters.  For example the following line has the cursor at the end of the word "edit":</p>
<pre>
foo( edit[TAB]
</pre>
<p>Because the input is split at the space character we're trying to complete the word "edit" (which will probably become <a href="/lua/editor.html">editor</a>.  Without that space?  We'd still be completing "edit" - because "(" is another valid character to split the line at.</p>
<p>The complete list of characters which lines are split upon is fetched/updated by the Lua function <a href="/lua/completion_chars.html">completion_chars</a>.  You can change this to alter the completion code.</p>
<p>Similarly you can configure the completion to be case-sensitive via "ignore_case" boolean variable:</p>
<pre>
-- ignore case when completing - the default
ignore_case = true

-- Case is considered
ignore_case = false
</pre>
<p>When ambiguity is present for completion you'll be presented with a list of possible matches.  Press TAB repeatedly to select the completion you prefer, or press Esc to cancel and complete manually.</p>
</blockquote>


<p>&nbsp;</p>


<h4 id="faq_gpg">How can I handle GPG?</h4>
<blockquote>
<p>TODO:  <a href="https://github.com/skx/lumail/issues/87#issuecomment-22605624">https://github.com/skx/lumail/issues/87#issuecomment-22605624</a></p>
</blockquote>


<p>&nbsp;</p>


<h4 id="faq_iterate">How can I iterate over messages?</h4>
<blockquote>
<p>The traditional way of iterating over messages is to start at message zero, and advance one message at a time, until you hit the final one.  This is achieved like so:</p>
<pre>
function iterate()
   offset = 0
   while( offset &lt; count_messages() )
      jump_index_to( offset )

      -- do your processing here.

      offset = offset + 1
   end
end
</pre>
<p>This works perfectly, but it surprises people because it starts iterating from the first messages in the current index-view, rather than the current position.  To resolve this problem the <a href="/lua/index_offset.html">index_offset()</a> primitive was added.</p>
<p>Using the index primitive you can start iterating forward from the current position, like so:</p>
<pre>
-- Start from the current position, stop on the last message.
function iterate()
   offset = <b>index_offset()</b>
   while( offset &lt; count_messages() )
      jump_index_to( offset )

      -- do your processing here.

      offset = offset + 1
   end
end
</pre>
<p>This will iterate from the current message to the end of the list, which is generally what people want.  The final alternative is to start from the current position and iterate forward, wrapping when we hit the end of the list:</p>
<pre>
-- Start from the current position, continue until we wrap around.
function iterate()
   cur = index_offset()
   max = count_messages()

   -- start from the next message.
   offset = cur + 1
   if ( offset > max ) then offset = 0 end

   while( offset != cur )
      jump_index_to( offset )

      -- do your processing here.


      -- jump forward, but reset to the start if you hit the last message
      offset = offset + 1
      if ( offset > max ) then
          offset = 0
      end
   end
end

</pre>
</blockquote>


<p>&nbsp;</p>

<h4 id="faq_sort">Why is the sort-order of my messages wrong?</h4>
<blockquote>
<p>Lumail has several different sorting methods that can be applied to folders, which are set with the <a href="/lua/sort.html">sort()</a> method.</p>
<p>Because it is the fastest we default to sorting messages by the modification time of the files which messages are stored in.  This only requires the use of <span class="tt">stat()</span>, rather than parsing the Date: headers of each message.</p>
<p>If you're using offlineimap, or some other tool, which manipulates the <span class="tt">mtime</span> of message-files on-disk then you should use :</p>
<pre>
-- slower, but more accurate sorting method
sort( "header-asc" );
</pre>
</blockquote>


<p>&nbsp;</p>

<h4 id="faq_state">Many functions need to save/restore state, how can that be done?</a></li></h4>
<blockquote>
<p>Many operations involve changing the global-mode, or limits, programatically.  If these limits aren't saved/restored then the user will be surprised by user-interface changes.</p>
<p>To avoid this a common idiom is to save/restore state.  This can be as basic as:</p>
<pre>
-- save mode / limits
old_mode   = global_mode()
old_ilimit = index_limit()
old_mlimit = maildir_limit()

--
-- ...
--

-- restore
global_mode( old_mode )
index_limit( old_ilimit )
maildir_limit( old_mlimit)
</pre>
<p>However this doesn't take into account selected folders, or message offsets.  It is perhaps more useful to wrap the save/restore steps into distinct functions.  That is what the <a href="/examples/state.html">save_state() &amp; load_state()</a> functions do.</p>
</blockquote>

<p>&nbsp;</p>

<h4 id="faq_msmtp">How can I use msmtp?</h4>
<blockquote>
<p><a href="http://msmtp.sourceforge.net/">msmtp</a> is a simple mail client which works as a relay for sending outgoing mail.  In general you can use any command-line client for sending mail, so long as:</p>
<ul>
<li>The client can accept submissions on STDIN.</li>
<li>The client has a consistent set of command-line  arguments.</li>
</ul>
<p>You'd set the path to the binary to use via <a href="/lua/sendmail_path.html">sendmail_path()</a> and all would be well.  Unfortunately <span class="tt">msmtp</span> requires the recipient to be specified upon the command-line, which makes using it a little more involved.</p>
<p>The following example shows how to handle using it:</p>
<pre>
--
-- msmtp needs to know which account you are using to send the mail and also
-- to whom the mail should be sent.
--
-- The account name will be saved in a global variable 'cur_acc' and the
-- recipient's email address can be parsed from the outgoing message via
-- the <a href="/lua/on_send_message.html">on_send_message()</a> hook.
--
-- In short we're updating the command-line to use, to include the recipient
-- every time we're sending a message.  A similar result could be achieved
-- by setting <a href="/lua/sendmail_path.html">sendmail_path()</a> to a
-- shell-script which parsed the message, and invoked mstpd.
--

--
-- Path to binary
msmtp_path = '/usr/bin/msmtp'

-- The account that is used, as specified in the msmtprc file
cur_acc = 'gmail'

--
-- Update the path to the mail-program to include the recipient address
-- in the arguments.
--
function on_send_message(filepath)
    local f = assert(io.open(filepath, 'r'))
    while true do
        local line = f:read('*line')
        if ( string.find( line, "To:", 1, true )  ) then

             -- the first 3 characters are "To:"
            to = string.sub(line, 4)

            sendmail_path(msmtp_path .. ' -a ' .. cur_acc .. ' ' .. to)
            break
        end
    end
    f:close()
end
</pre>
</blockquote>