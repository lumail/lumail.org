Title: Technical FAQ
----


<blockquote>
 <ul class="invisible">
  <li><a href="#faq_bodies">How can I modify message bodies?</a></li>
  <li><a href="#faq_rfc2047">Parsing of headers is broken (to/from/subject)?</a></li>
  <li><a href="#faq_tab">How does TAB-completion, and character input work?</a></li>
  <li><a href="#faq_gpg">How can I handle GPG?</a></li>
  <li><a href="#faq_iterate">How can I iterate over messages?</a></li>
 </ul>
 <p>&nbsp;</p>
</blockquote>


<p>&nbsp;</p>

<h4 id="faq_bodies">How can I modify message bodies?</h4>
<blockquote>
<p>There are times when it is necessary to modify a message prior to display.  Lumail provides two opportunities to modify the message:</p>
<ul>
<li><a href="/lua/mail_filter.html">mail_filter()</a></li>
<li><a href="/lua/display_filter.html">display_filter()</a></li>
</ul>
<p>Initially a message is read from disk, and the body is piped through the <span class="tt">mail_filter()</span> command, if one is set.</p>
<p>Then the resulting output will be parsed such that the first text/plain MIME component can be displayed.  Just prior to the display this text will be passed through the shell-command defined in <span class="tt">display_filter</span>.</p>
<p>This means you have two ways of filtering a command, both via the shell:</p>
<ul>
<li><span class="tt">display_filter</span> - Will filter just the first text/plain part, and will be done prior to display.</li>
<li><span class="tt">mail_filter</span> - Will filter just the whole message (headers, attachments, and all).</li>
</ul>
<p>If you need to convert HTML to text then you'd use the second filter.  If you want to snip excessive quoting you'd use the first filter.</p>
</blockquote>


<p>&nbsp;</p>


<h4 id="faq_rfc2047">Parsing of headers is broken (to/from/subject)?</h4>
<blockquote>
<p>We use <a href="http://spruce.sourceforge.net/gmime/">GMime</a> for parsing headers, message-bodies, and attachments.</p>
<p>By default GMime is pretty strict, but it has a looser mode which can be enabled via custom flags.  If you're seeing some oddities with decoding of headers in particular please set the environmental variable <span class="tt">RFC2047</span> to a non-empty value.</p>
<p>Upon a typical host you could do that via:</p>
<pre>
RFC2047=1 lumail [...args...]
</pre>
</blockquote>


<p>&nbsp;</p>

<h4 id="faq_tab">How does TAB-completion, and character input work?</h4>
<blockquote>
<p>Every time you're prompted for input, in the status-area, the code which handles it is that used by the <a href="/lua/prompt.html">prompt()</a> primitive.   This function reads individual characters and allows you to enter a complete "line".</p>
<p>This function has been written to have the standard keybindings you might find via readline, etc.  For example:</p>
<ul>
<li><span class="tt">Ctrl-a</span>: Go to beginning of line.</li>
<li><span class="tt">Ctrl-b</span>: Go backwards one character.</li>
<li><span class="tt">Ctrl-e</span>: Go to the end of line.</li>
<li><span class="tt">Ctrl-f</span>: Go forwardso ne character.</li>
<li><span class="tt">Ctrl-k</span>: Kill the reminder of the line.</li>
</ul>
<p>The reading of individual characters, along with all keyboard input, uses two sources of keys:</p>
<ul>
<li>The private input queue which has been seeded with <a href="/lua/stuff.html">stuff()</a>.</li>
<li>The ncurses input queue.</li>
</ul>
<p>By using the private input buffer, and only reading the keyboard with ncurses when that is empty, we allow the user-interface to be driven via automation, which is very useful.</p>
<p>The only part of the input-phase which is non-deterministic is the TAB-completion support.  When you're entering a line and you press TAB the line you've entered is broken into two parts:</p>
<ul>
<li>The start of the line, which is left unchanged.</li>
<li>The "word" you're currently entering, which is passed to the completion code.</li>
</ul>
<p><p>(i.e. Rather than using TAB-completion to complete a line it is always used to complete the "word", or token, you're currently entering.)</p>
<p>The word you're completing is determined by breaking up the line into pieces, based upon a small list of terminating-characters.  For example the following line has the cursor at the end of the word "edit":</p>
<pre>
foo( edit[TAB]
</pre>
<p>Because the input is split at the space character we're trying to complete the word "edit" (which will probably become <a href="/lua/editor.html">editor</a>.  Without that space?  We'd still be completing "edit" - because "(" is another valid character to split the line at.</p>
<p>The complete list of characters which lines are split upon is fetched/updated by the Lua function <a href="/lua/completion_chars.html">completion_chars</a>.  You can change this to alter the completion code.</p>
<p>Similarly you can configure the completion to be case-sensitive via "ignore_case" boolean variable:</p>
<pre>
-- ignore case when completing - the default
ignore_case = true

-- Case is considered
ignore_case = false
</pre>
<p>When ambiguity is present for completion you'll be presented with a list of possible matches.  Press TAB repeatedly to select the completion you prefer, or press Esc to cancel and complete manually.</p>
</blockquote>


<p>&nbsp;</p>


<h4 id="faq_gpg">How can I handle GPG?</h4>
<blockquote>
<p>TODO:  <a href="https://github.com/skx/lumail/issues/87#issuecomment-22605624">https://github.com/skx/lumail/issues/87#issuecomment-22605624</a></p>
</blockquote>


<p>&nbsp;</p>


<h4 id="faq_iterate">How can I iterate over messages?</h4>
<blockquote>
<p>The traditional way of iterating over messages is to start at message zero, and advance one message at a time, until you hit the final one.  This is achieved like so:</p>
<pre>
function iterate()
   offset = 0
   while( offset &lt; count_messages() )
      jump_index_to( offset )

      -- do your processing here.

      offset = offset + 1
   end
end
</pre>
<p>This works perfectly, but it surprises people because it starts iterating from the first messages in the current index-view, rather than the current position.  To resolve this problem the <a href="/lua/index_offset.html">index_offset()</a> primitive was added.</p>
<p>Using the index primitive you can start iterating forward from the current position, like so:</p>
<pre>
-- Start from the current position, stop on the last message.
function iterate()
   offset = <b>index_offset()</b>
   while( offset &lt; count_messages() )
      jump_index_to( offset )

      -- do your processing here.

      offset = offset + 1
   end
end
</pre>
<p>This will iterate from the current message to the end of the list, which is generally what people want.  The final alternative is to start from the current position and iterate forward, wrapping when we hit the end of the list:</p>
<pre>
-- Start from the current position, continue until we wrap around.
function iterate()
   cur = index_offset()
   max = count_messages()

   -- start from the next message.
   offset = cur + 1
   if ( offset > max ) then offset = 0 end

   while( offset != cur )
      jump_index_to( offset )

      -- do your processing here.


      -- jump forward, but reset to the start if you hit the last message
      offset = offset + 1
      if ( offset > max ) then
          offset = 0
      end
   end
end

</pre>
</blockquote>

